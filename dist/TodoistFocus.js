// Variables used by Scriptable.
// These must be at the very top of the file. Do not edit.
// icon-color: red; icon-glyph: book-open;
const o="20fdade709c084c2e255e56e57d0e53370e8283e",t="TodoistFocusCache.json";async function n(){console.log("Starting getTask() ...");const n=await async function(){const t=new Request("https://api.todoist.com/sync/v9/sync");t.method="POST",t.headers={"Content-Type":"application/json",Authorization:`Bearer ${o}`},t.body=JSON.stringify({sync_token:"*",resource_types:'["filters"]'});return(await t.loadJSON()).filters}();console.log("Filters received: "+JSON.stringify(n));const a=n.reduce(((o,t)=>"â­ðŸŸ¢ Focused"===t.name?t:o),null);if(console.log("Found filter: "+JSON.stringify(a)),null==a)throw console.log("No filter found by given name"),console.log(n),new Error("No filter found by given name");console.log(`Filter found ${JSON.stringify(a)}`);const i=await async function(){const o=await r(t);return console.log(`cache: ${JSON.stringify(o)}`),null!=o.lastTaskId?o.lastTaskId:null}(),l=a.query.split(",").map((t=>async function(t){const n="?filter="+encodeURIComponent(t),e=new Request(`https://api.todoist.com/rest/v2/tasks${n}`);let r;e.method="GET",e.headers={"Content-Type":"application/json",Authorization:`Bearer ${o}`};try{r=await e.loadJSON()}catch(o){if(e.response&&410===e.response.statusCode)return console.error("Filter not recognized or no longer valid. Returning no tasks for this query."),[];console.error("Error parsing JSON response in getTasksByFilter(): "+JSON.stringify(o));try{const o=await e.loadString();console.log("Raw response text: "+o)}catch(o){console.error("Failed to read raw response: "+JSON.stringify(o))}throw o}return r}(t))),s=await Promise.all(l);console.log("taskSections: "+JSON.stringify(s));for(const o of s)if(o.length>0){let t=Math.floor(Math.random()*o.length*.999);if(null!=i)for(let n=0;n<o.length;n++)if(o[n].id===i){t=n;break}const n=o[t];return await e(n.id),n}return{content:"NO TASK FOUND"}}async function e(o){const n=await r(t);n.lastTaskId=o,await function(o,t){const n=FileManager.iCloud(),e=n.joinPath(n.libraryDirectory(),"cache"),r=n.joinPath(e,o);n.fileExists(e)||n.createDirectory(e);const a=JSON.stringify(t);n.writeString(r,a)}(t,n)}function r(o){const t=FileManager.iCloud(),n=t.joinPath(t.libraryDirectory(),"cache"),e=t.joinPath(n,o);if(!t.fileExists(e))return console.log(`File does not exist: ${e}`),{};try{t.downloadFileFromiCloud(e)}catch(o){return console.log(`Error downloading file from iCloud: ${o}`),{}}let r;try{r=t.readString(e)}catch(o){return console.log(`Error reading file: ${o}`),{}}try{return JSON.parse(r)}catch(o){return console.log(`Error parsing JSON: ${o}`),{}}}await async function(){const o=new ListWidget;o.useDefaultPadding();try{const t=await n(),e=Color.dynamic(new Color("gray"),new Color("gray")),r=Color.dynamic(new Color("lightGray"),new Color("lightGray")),a=Color.dynamic(new Color("black"),new Color("black")),i=new LinearGradient;i.colors=[e,r],i.locations=[0,1],console.log({gradient:i}),o.backgroundGradient=i;const l=o.addStack();l.layoutHorizontally(),l.topAlignContent(),l.setPadding(0,0,0,0);const s=l.addStack();s.layoutVertically(),s.topAlignContent(),s.setPadding(0,0,0,0),l.addSpacer();const c=s.addStack();c.layoutHorizontally(),c.topAlignContent(),c.setPadding(0,0,0,0);const d=c.addText("Top Task".toUpperCase());d.textColor=a,d.font=Font.regularSystemFont(11),d.minimumScaleFactor=1;const g=s.addStack();g.layoutHorizontally(),g.topAlignContent(),g.setPadding(0,0,0,0);const u=g.addText(t.content);u.textColor=a,u.font=Font.semiboldSystemFont(25),u.minimumScaleFactor=.3,s.addSpacer(),void 0!==t.id&&(o.url=`todoist://task?id=${t.id}`)}catch(t){if(console.error("An error occurred in run(): "+JSON.stringify(t)),console.log("Stack trace: "+(t&&t.stack?t.stack:"No stack trace available")),666===t){o.backgroundColor=new Color("999999");const t=o.addText("Error".toUpperCase());t.textColor=new Color("000000"),t.font=Font.regularSystemFont(11),t.minimumScaleFactor=.5,o.addSpacer(15);const n=o.addText("Couldn't connect to the server.");n.textColor=new Color("000000"),n.font=Font.semiboldSystemFont(15),n.minimumScaleFactor=.3}else{console.log(`Could not render widget: ${t}`);const n=o.addText(`${t}`);n.textColor=Color.red(),n.textOpacity=30,n.font=Font.regularSystemFont(10)}}config.runsInApp&&await o.presentSmall(),Script.setWidget(o),Script.complete()}();
